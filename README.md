版本更新日志
-------------------------------------------------------------------------
2021.8.6
最初的版本。目前存在的问题：
1. 有field为class的时候，没有判空。（当然，作为Unity序列化数据的使用是没有问题的）
2. 当存在一个field，继承自List<T>的时候，不会被认为是数组类型的，后面应当使用类似于Odin中TypeExtension中判断一个类型是否继承自List<T>的做法来实现数组类型的相关操作。
3. 有些ILEmit中代码太长了，应当抽取常用部分，构建面向对象的IL编程。
4. 关于Clone方法，后面需要想办法使得第一个参数带ref，使得更方便的使用，否则，参数中带有null的一些情况可能不能令人满意。但是测试一下发现lambda中参数似乎不能用ref修饰。后面可能需要考虑类似于在Clone方法的参数中带一个上带一个父类上下文，来避免这个问题。（2021.8.14已解决）
-------------------------------------------------------------------------
2021.8.8
更新如下：
1. 检查了field为class的情况下，有null存在的情况。
2. 对il提供了一些便利的扩展（例如if-then-else块等等），后续需要扩展更多常用的语句，并重构以前的代码结构。
3. 新问题：在处理class为null的情况突然发现，解析数组类型的时候，只考虑了作为field存在的时候，没有考虑来源也为数组的时候，例如List<List<T>>。（总结一下，只要当前域可能为null，就要处理三种情况的来源，作为顶层参数，作为常规field，作为数组的item）
4. 新问题：发现没有处理field为高维数组的情况。
-------------------------------------------------------------------------
2021.8.14
更新如下：
1. 修复了List<T>中T一些类型在new的时候考虑漏的情况。
2. 引入了一个据说是来自于Orleans框架深拷贝的DeepCopy源码（https://github.com/ReubenBond/DeepCopy ），想到了第一个参数不能带ref的解决方案，利用 a = clone(b); 来保证值能被正确带出，但是一直new可能性能会欠佳，因此考虑 a = clone(a, b); 的形式，将a传入，避免a本身不为null的情况也被new一次，来提升效率。 大致测试了一下性能以后发现这种优化速度可以提升10倍左右，非常nice！
3. 新问题：发现没有处理Dictionary相关的深拷贝。
-------------------------------------------------------------------------
2021.8.20
更新如下：
1. 修复了深拷贝时struct的class处理不正确的情况，加载域应当使用ldflda而不是ldfld。
-------------------------------------------------------------------------
2021.8.23
更新如下：
1. 需要注意的是当struct作为class的域被直接用等号赋值的时候，使用ldfld；当对struct的域进行赋值时，加载struct必须使用ldflda。

-------------------------------------------------------------------------
2022.9.24
更新如下：
1. 修复了 a = clone(b) 形式的拷贝在最顶层直接赋值时由于参数错误会报错的情况

新问题：
1. 发现拷贝失效的类：Unity的AnimationCurve（本质是没处理property的情况）（9.25已解决）
-------------------------------------------------------------------------
2022.9.25
更新如下：
1. 实现了对property的拷贝处理
2. 修复了T[]类型的一些bug
3. 修复了数组类型下对struct字段进行赋值的bug，例如 List<Position> list, 使用 list[i].x = val 的情况
4. 修复了部分Unity类型下T[]类型字段的拷贝问题，原因在于Unity对外的数组一般使用property的形式进行处理，并且返回一份拷贝，导致在赋值时失效（例如AnimationCurve的keys，类型为Keyframe[]）（现在的处理方式是将Unity类型下的T[]字段直接复制）

新问题：
1. 考虑到对递归类型是逐一获取子字段来生成代码，在面对 A 字段中含有 List<A> 的情形，在生成方法时就会由于递归直接死循环，应该采用对相同类型采用Cache的做法（但是如何处理例如链表形式的A中直接带有A呢？可能需要ForwardDeclare之类的处理方式）
2. 深比较中没有进行对property的处理，可能会导致cmp和clone不一致的情况
3. 基于更新的第4点，处理流程需要优化，最后的流程应该为：先从原数组中获取拷贝，从目标数组中进行内容复制，最后将拷贝返还给原数组。
